# Common Sorting Algorithms

查找和排序算法是算法的入门知识，其经典思想可以用于很多算法当中。因为其实现代码较短，应用较常见，所以在面试中经常会问到排序算法及其相关的问题。但万变不离其宗，只要熟悉了思想，灵活运用也不是难事。**一般在面试中最常考的是快速排序和归并排序**，并且经常有面试官要求现场写出这两种排序的代码，对这两种排序的代码一定要信手拈来才行。还有**插入排序、冒泡排序、堆排序、基数排序、桶排序**等，面试官对于这些排序可能会要求比较各自的优劣、各种算法的思想及其使用场景，并分析算法的时间和空间复杂度。通常查找和排序算法的考察是面试的开始，如果这些问题回答不好，估计面试官都没有继续面试下去的兴趣都没了，所以想开个好头就要把常见的排序算法思想及其特点要熟练掌握，有必要时要熟练写出代码。
  
### 冒泡排序
冒泡排序是最简单的排序之一了，其大体思想就是**通过与相邻元素的比较和交换来把小的数交换到最前面**。这个过程类似于水泡向上升一样，因此而得名。
  
举个例子，对5,3,8,6,4这个无序序列进行冒泡排序。首先从后向前冒泡，4和6比较，把4交换到前面，序列变成5,3,8,4,6。同理4和8交换，变成5,3,4,8,6，3和4无需交换，5和3交换，变成3,5,4,8,6,3。这样一次冒泡就完了，把最小的数3排到最前面了。对剩下的序列依次冒泡就会得到一个有序序列。冒泡排序的时间复杂度为\(O(n^2)\)。

**实现代码：**
```java
/**
 * @Description:冒泡排序
 * @ClassName: BubbleSort 
 * @author Jia Zheng
 * @time 2017年6月13日 下午12:19:56
 */
public class BubbleSort {
	public static void bubbleSort(int[] arr) {
		if(arr == null || arr.length == 0)
			return ;
		for(int i = 0; i < arr.length; i++){
			for(int j = arr.length-1; j > i; j--){
				if(arr[j] < arr[j-1]){
					Swap.swap(arr,j-1,j);
				}
			}
		}
	}
}
```

### 选择排序
选择排序的思想其实和冒泡排序有点类似，都是在一次排序后把最小的元素放到最前面，但是过程不同，**冒泡排序是通过相邻的比较和交换，而选择排序是通过对整体的选择**。
  
举个例子，对5,3,8,6,4这个无序序列进行简单选择排序，首先要选择5以外的最小数来和5交换，也就是选择3和5交换，一次排序后就变成了3,5,8,6,4。对剩下的序列一次进行选择和交换，最终就会得到一个有序序列。其实选择排序可以看成冒泡排序的优化，因为其目的相同，只是选择排序只有在确定了最小数的前提下才进行交换，大大减少了交换的次数。选择排序的时间复杂度为\(O(n^2)\)。

**实现代码：**
```java
/**
 * @Description:选择排序
 * @ClassName: SelectSort 
 * @author Jia Zheng
 * @time 2017年6月13日 下午12:32:29
 */
public class SelectSort {
	public static void selectSort(int[] arr) {
		if(arr == null || arr.length == 0)
			return;
		int minIndex = 0;
		for (int i = 0; i < arr.length - 1; i++) {
			minIndex = i;
			for (int j = i + 1; j < arr.length; j++) {
				if(arr[j] < arr[minIndex]){
					minIndex = j;
				}
			}
			if(minIndex != i)
				Swap.swap(arr, i, minIndex);
		}
	}
}
```

### 插入排序
**插入排序不是通过交换位置而是通过比较找到合适的位置插入元素来达到排序的目的的**。相信大家都有过打扑克牌的经历，特别是牌数较大的，在分牌时可能要整理自己的牌，牌多的时候怎么整理呢？就是拿到一张牌，找到一个合适的位置插入，这个原理其实和插入排序是一样的。
  
举个例子，对5,3,8,6,4这个无序序列进行简单插入排序，首先假设第一个数的位置时正确的，想一下在拿到第一张牌的时候，没必要整理，然后3要插到5前面，把5后移一位，变成3,5,8,6,4，然后8不用动，6插在8前面，8后移一位，4插在5前面，从5开始都向后移一位。注意在插入一个数的时候要保证这个数前面的数已经有序。简单插入排序的时间复杂度也是\(O(n^2)\)。

**实现代码：**
```java
/**
 * @Description:插入排序
 * @ClassName: InsertSort 
 * @author Jia Zheng
 * @time 2017年6月13日 下午12:54:39 
 */
public class InsertSort {
	public static void inserSort(int arr[]) {
		if (arr == null ; arr.length ==0) {
			return;
		}
		// 假设第一个位置的元素处于正确的位置
		for (int i = 1; i < arr.length; i++) {
			int j = i;
			// 待确定位置的元素
			int target = arr[j];
			// 为target元素寻找合适的位置，大于target的元素后移
			while (j >= 0 && target > arr[j-1]) {
				arr[j] = arr[j-1];
				j--;
			}
			// 插入
			arr[j] = target;
		}
	}
```




